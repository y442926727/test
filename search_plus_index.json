{"./":{"url":"./","title":"序言","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 主要内容 前提基础 学习建议 主要内容 主要是个人学习记录 涉及知识范围OS(Linux、Windows等)，DB(MySQL、SQL Server、redis等)，Web(JS、VUE、NodeJS等)、Server Language（Python，Java，Golang）等 前提基础 本人是以多年的C#开发经验为前提，按自己的理解来写作所有知识。可能不适合小白，还请见谅。 所有知识内容基本会参考如下大纲格式编写。 # 解决什么问题 # 诞生与发展历程 # 安装更新卸载（引用使用移除）[软件类] # 注意事项 # 高级知识点 这样的写作目的，是让所有读者一眼就知道，将要所读的内容，可以帮助我们解决什么实际问题。 我们大多数人学习的目的是为了解决根本眼前的问题。当不是自己想要的，快速跳过而节省时间。 学习建议 学习任何知识要保持空杯心态。任何知识都不可能全懂，就是已经学过的，如果再学习一遍很可能又有新的理解。 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2020-11-27 23:12:20 "},"knowledgecompile/":{"url":"knowledgecompile/","title":"知识库工具","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 markdown 简介 编写工具 语法 个人体会 Typora 标题自动编号 gitbook 安装 gitbook 验证安装 初使化目录 生成 本地预览 配置文件（不是必需的） gitbook插件 卸载GitBook 常用命令 关于目录插件 问题 问题（warn\"options\"） 问题（第一个h1生成不了页面目录） 问题（gitbook部署后相对路径资源文件404问题） 构建或启动时报错 gitbook install 报错 解决什么问题需要markdown 原来我们在记录笔记时通常是用word，或者更低级的txt。前者虽然可以编辑复杂的格式，但是为了将笔记的格式或样式排版的更美观，需要花掉我们大量的时间。后者不仅不能存放笔记图片，而且所有文字只能都是一个字体，内容更是没有主次和顺序之分。 而我们记笔记的目的，是着重于笔记内容本身，而非排版。 所以我们希望有能通过一个手段或者一个编辑工具，来实现我们。而Markdown应运而生，Markdown用简洁的语法代替排版，其是一种轻量级的标记语言，而我们使用的就是Typora 编辑器。 所有知识库内容将用markdown标记语言编写，并用gitbook生成html在线教程，上传至CentOS服务器通过nginx访问。 markdown 简介 Markdown是一种轻量级的标记语言，它允许人们使用易读易写的纯文本格式编写文档，借助可实现快速排版且转换成格式丰富的HTML页面。目前被越来越多的写作爱好者及工作者使用。其语法十分简单，常用标记符号少，学习时间少，一旦掌握这种标记语言，将极大提高效率。但是若需要复杂排版如左右对齐缩进等，还是选择word等专业软件。 Markdown用简洁的语法代替排版，而不像常用文字处理软件Word或Pages等进行排版、字体、插入等设置。标记语言可以通过键盘即实现字体大小、插入表格，图片，超链接，脚注等。 Markdown的优点 最大好处是：快速掌握。 简单，适合所有人群，方便打开，不至于出现低版本word打不开高版本word的文档。 避免软件不同，如对方是wps，看到的word文档效果和你不一样。 方便快速排版，节省时间。 轻松的导出为HTML、PDF格式。 纯文本内容，兼容所有的文本编辑器与文字处理软件。 支持Markdown语法的编辑器有很多，部分网站也支持。 编写工具 这里我推荐使用typora，因为它可以所以见即所得，不会像他编辑工具一样，左边编辑，右边预览。 语法 语法学习 《了不起的Markdown》 个人体会 markdown让我们程序员，在记录知识时省却了排版所浪费的时间，而且支持代码块，流程图等。在word上程序代码不支持高亮，而且排版格式不适宜代码显示等。而markdown会让你心情愉悦，只需在编辑内容上用心即可。 Typora 标题自动编号 Typora其实是将markdown转换成html展示给我们看的，而且默认层级显示是没有序号，只有字体大小。所以我们需要通过css让其显示序号，让笔记更有层次感。 在主题文件夹下开创建base.user.css文件，复制粘贴一下css样式代码： /** initialize css counter */ #write { counter-reset: h1 } h1 { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #write h1:before { counter-increment: h1; content: counter(h1) \". \" } #write h2:before { counter-increment: h2; content: counter(h1) \".\" counter(h2) \". \" } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \". \" } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \". \" } #write h5:before, h5.md-focus.md-heading:before { counter-increment: h5; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \". \" } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \". \" } /** override the default style for focused headings */ #write>h3.md-focus:before, #write>h4.md-focus:before, #write>h5.md-focus:before, #write>h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } /*左侧大纲目录序号*/ .sidebar-content { counter-reset: h1 } .outline-h1 { counter-reset: h2 } .outline-h2 { counter-reset: h3 } .outline-h3 { counter-reset: h4 } .outline-h4 { counter-reset: h5 } .outline-h5 { counter-reset: h6 } .outline-h1>.outline-item>.outline-label:before { counter-increment: h1; content: counter(h1) \". \" } .outline-h2>.outline-item>.outline-label:before { counter-increment: h2; content: counter(h1) \".\" counter(h2) \". \" } .outline-h3>.outline-item>.outline-label:before { counter-increment: h3; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \". \" } .outline-h4>.outline-item>.outline-label:before { counter-increment: h4; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \". \" } .outline-h5>.outline-item>.outline-label:before { counter-increment: h5; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \". \" } .outline-h6>.outline-item>.outline-label:before { counter-increment: h6; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \". \" } mark { background: white; color: red; font-weight: bold; border-bottom: 0px solid white; padding: 0.0px; margin: 0 0px; } ::selection { background-color: Lime; color: red;} gitbook gitbook安装与使用（含常用插件和book.json配置详解） 是什么？ 在我认识 GitBook 之前，我已经在使用 Git 了，毋容置疑，Git 是目前世界上最先进的分布式版本控制系统。 我认为 Git 不仅是程序员管理代码的工具，它的分布式协作方式同样适用于很多场合，其中一个就是写作（这会是一个引起社会变革的伟大的工具！）。所以在我发现 GitBook 之前，实际上我已经无数次想象过它的使用场景了。 咋一看 GitBook 的名字，你可能会认为它是关于 Git 的一本书。而当你有所了解之后，你也许会认为它是一个使用 Git 构建电子书的工具。其实不然，GitBook 与 Git 的关系，就像雷锋塔和雷锋那样，没有一点关系！ 实际上，GitBook 是一个基于 Node.js 的命令行工具，支持 Markdown 和 AsciiDoc 两种语法格式，可以输出 HTML、PDF、eBook 等格式的电子书。所以我更喜欢把 GitBook 定义为文档格式转换工具。 所以，GitBook 不是 Markdown 编辑工具，也不是 Git 版本管理工具。市面上我们可以找到很多 Markdown 编辑器，比如 Typora、MacDown、Bear、MarkdownPad、MarkdownX、JetBrains’s IDE（需要安装插件）、Atom、简书、CSDN 以及 GitBook 自家的 GitBook Editor 等等。 安装 gitbook GitBook 是一个基于 Node.js 的命令行工具，下载安装 Node.js，安装完成之后，你可以使用下面的命令来检验是否安装成功。 注意Node.js 对Gitbook存在兼容问题，截止2020年10月17日，LST版本为12.18.4，最新版13.9.0。建议用LTS版本。 在https://nodejs.org/en/download/releases/中，可以查看所有Node.js版本。 $ node -v v12.18.4 确认安装完node.js后再执行一下命令 npm install gitbook-cli -g #或者（yarn类似于npm安装方式，具体参考node.js章节） yarn global add gitbook-cli 验证安装 gitbook -V 注意：若输入上面命令后，提示Installing GitBook，时间较长，请耐心等待。 初使化目录 gitbook init 会发现目录下面多了2个文件，README.md和SUMMARY.md README.md 和 SUMMARY.md 是两个必须文件 README.md 是对书籍的简单介绍 SUMMARY.md 是书籍的目录结构 生成 #生成在当前目录的默认文件夹 _book里面 gitbook build #生成在当前目录的默认文件夹 指定的out 里面 gitbook build ./out #当前除文件夹md外，生成到out文件夹中 gitbook build ./md ./out 本地预览 #注意server没有r。默认端口4000 gitbook serve --port 8088 http://localhost:4000 配置文件（不是必需的） 在目录下创建book.json文件，json对象在使用过成中，不允许注释，请复制粘贴后删除注释部分。 { \"title\": \"前端规范\", \"description\": \"前端规范 简介\", \"language\": \"zh-hans\", \"plugins\": [ \"-lunr\", \"-search\", \"code\", //代码行号插件和复制 \"search-plus\", //支持中文搜索 上面 search 是默认的 “-” 是去掉的意思 \"splitter\", // 这个侧边可以拉伸 \"tbfed-pagefooter\", //这个是底部加 信息 下面可以看到具体的配置 \"expandable-chapters-small\"//使左侧的章节目录可以折叠 \"page-treeview\", //页面头部目录 \"page-toc-button\", //右侧悬浮目录导航 \"icp\" //备案信息 ], \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy xxxxx\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" }, \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 }, \"icp\": { \"label\": \"\", \"number\": \"浙ICP备18042346号\", \"link\": \"http://beian.miit.gov.cn/\", \"style\": { \"color\": \"#f72b07\" } }, \"links\": { \"gitbook\": false, \"sharing\": { \"google\": false, \"facebook\": false, \"twitter\": false, \"all\": false } } } 上面配置好后，启动服务会报错，这样需要我们安装gitbook插件 gitbook插件 gitbook仓库（使用gitbook-plugin-{插件名称}关键字搜索） 常用插件 #插件只要在第6节描述的json中配置好后，再执行该命令，就会自动安装（太慢） gitbook install #推荐使用（会使用nodejs镜像安装） npm install gitbook-plugin-{插件名称} 【提醒】因为gitbook项目不是标准的nodejs项目，所以安装会出现如下图警告，请不要理会。 安装的插件都在当前目录下的node_modules文件夹下 #所以可以插件目录下按需删除，对插件卸载。也可将整个文件夹删除卸载。 rmdir /s/q node_modules\\ 卸载GitBook rmdir /s/q C:\\Users\\{User}\\.gitbook #找到并删除此文件夹 删除后执行命令 npm uninstall -g gitbook npm uninstall -g gitbook-cli # 清除npm缓存 npm cache clean --force 常用命令 gitbook init //初始化目录文件 gitbook help //列出gitbook所有的命令 gitbook --help //输出gitbook-cli的帮助信息 gitbook build //生成静态网页 gitbook serve //生成静态网页并运行服务器 gitbook build --gitbook=2.0.1 //生成时指定gitbook的版本, 本地没有会先下载 gitbook ls //列出本地所有的gitbook版本 gitbook ls-remote //列出远程可用的gitbook版本 gitbook fetch 标签/版本号 //安装对应的gitbook版本 gitbook update //更新到gitbook的最新版本 gitbook uninstall 2.0.1 //卸载对应的gitbook版本 gitbook build --log=debug //指定log的级别 gitbook builid --debug //输出错误信息 关于目录插件 因为我们标题序号都是通过css自动生成，所以我们gitbook构建出的html，标题及目录也要用css生成编号。故我们要在项目目录下创建styles/website.css文件夹及文件，这样构建后，html会自动引用该样式。 /*隐藏page-treeview目录的版权信息*/ .treeview__container-title{ display: none; } /*给头部目录增加编号*/ .markdown-section li {counter-increment:a 1;} .markdown-section li a:before{content:counter(a)\". \";} .markdown-section li li {counter-increment:b 1;} .markdown-section li li a:before{content:counter(a)\".\"counter(b)\". \";} .markdown-section li li li {counter-increment:c 1;} .markdown-section li li li a:before{content:counter(a)\".\"counter(b)\".\"counter(c)\". \";} .markdown-section li li li li {counter-increment:d 1;} .markdown-section li li li li a:before{content:counter(a)\".\"counter(b)\".\"counter(c)\".\"counter(d)\". \";} /*给悬浮目录增加编号*/ .page-toc-menu li {counter-increment:toca 1;} .page-toc-menu li a:before{content:counter(toca)\". \";} .page-toc-menu ul ul li {counter-increment:tocb 1;} .page-toc-menu ul ul li a:before{content:counter(toca)\".\"counter(tocb)\". \";} /*给标题增加编号*/ .markdown-section { counter-reset: h1} h1 {counter-reset: h2} h2 {counter-reset: h3} h3 {counter-reset: h4} h4 {counter-reset: h5} h5 {counter-reset: h6} .markdown-section h1:before {counter-increment: h1; content: counter(h1) \". \";} .markdown-section h2:before {counter-increment: h2; content: counter(h1) \".\" counter(h2) \". \"} .markdown-section h3:before {counter-increment: h3;content: counter(h1) \".\" counter(h2) \".\" counter(h3) \". \"} .markdown-section h4:before {counter-increment: h4; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \". \"} .markdown-section h5:before {counter-increment: h5; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \". \"} .markdown-section h6:before {counter-increment: h6; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \". \"} p {text-indent:2em} mark { background: white; color: red; font-weight: bold; border-bottom: 0px solid white; padding: 0.0px; margin: 0 0px; } ::selection { background-color: Lime; color: red;} 问题 问题（warn\"options\"） 该问题经过排除法和网络上类似问题描述，应该是所使用的插件版本自身某些语法规则不是最新的导致。 问题（第一个h1生成不了页面目录） 需要首行空一行 问题（gitbook部署后相对路径资源文件404问题） 这种资源文件提示404错误请忽略，这是因为gitbook布局不是用iframe，所以资源文件会在页面加载完后，js会再处理相对路径的资源文件。 构建或启动时报错 如果出现类似这样的错误，就删除_book文件夹，重新执行命令即可。 gitbook install 报错 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 20:04:37 "},"os/":{"url":"os/","title":"操作系统","keywords":"","body":"操作系统，有Window，MAC，Linux Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2020-10-25 21:55:52 "},"os/centos/":{"url":"os/centos/","title":"CentOS开发环境","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 CentOS8 简介 安装 系统目录结构说明 安装基础软件 安装epel 配置系统镜像源 升级内核 查看版本 启用 ELRepo 仓库 查看可用的系统内核包 安装最新版本内核 验证 删除旧内核 安装新版本工具包 常用命令 网络配置 关闭SELinux 防火墙 疑问 su命令与su - 命令的区别 切换root身份不同 采用su deploy命令后，取目标用户不同 service命令 用echo $PATH命令后，环境量不同 待整理或学习 Docker&Docker-compose的安装 docker 简介 安装准备 添加docker的yum源管理配置 查看docker-ce各个版本 安装docker-ce Centos8提示错误信息 常用命令 Docker-Compose安装 简介 安装（两种安装） 下载安装方式 pip安装方式 验证安装 详解Docker-Compose.yml文件 安装gitlab Docker安装gitlab 在DockerHub上搜索中文版本GitLab镜像 Pull GitLab镜像到本地 使用docker-compose启动gitlab容器 测试邮件 附加 免密登录 关于迁移或升级 迁移 升级 附加 Nexus Docker安装Nexus ※：所有命令通常是基于cd ~ 目录进行（即 当前用户目录 ）。除非有特殊说明，如“前后通过cd切换了目录”或“示例图片中明示了路径\"。切记CentOS 区分大小写，而Windows不区分。 CentOS8 简介 CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。 功能 CentOS 8 CentOS 7 内核版本 4.18.0-x 3.10.0-x 文件系统 XFS XFS 时间同步 只支持Chronyd 支持NTP和Chronyd 文件大小 8EB 500TB 文件系统大小 1PB 500TB 包管理工具 DNF（YUM v4） YUM（YUM v3） 最大内存 24TB 12TB 防火墙 nftables取代iptables firewalld底层使用iptables 支持架构 支持64-bit ARM 不支持64-bit ARM 网络管理 默认安装Cockpit 无默认安装 CPU日志 CPU日志记录在journald进程中 CPU相关日志位于/var/log/cups目录 发布时间 2019-09-24 2014-07-07 完整更新 2024-05-01 2020-08-06 支持IPv6 支持 Ready Logo Phase 2 Git 2.18 1.7 GCC 8.2.1 4.8.5 Python 3.6.6 2.7.5 Glibc 2.28 2.17 Boost 1.66 1.53 LLVM/Clang 6.0 5.0 安装 因为我们是搭建服务器环境我们再安装过程中选择最小安装，后续需要应用到的软件，我们按需安装。使我们的服务器占用硬件资源最少。 我们输入Chinese关键字，选择到中文语言 务必先将网络打开，因为后续进入系统时，安装软件都需要网络。避免因网络未打开，安装完系统进入后，还手动配置网络。 安装过程中我们可以设置root密码和创建用户。 查看CentOS的IP，方便XShell登录使用 系统目录结构说明 安装基础软件 因为我们选择的是最小安装，很多系统工具没有安装，导致很多命令没法使用，如ifconfig，vim，wget等 #解决ifconfig yum -y install net-tools #解决vim(vi是所有UNIX系统都会提供的屏幕编辑器，也有的称为多模式编辑器，它提供了一个视窗设备，通过它可以编辑文件，而vim则是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。如vim可以用不同的颜色来加亮你的代码、在vi里，按 u只能撤消上次命令，而在vim里可以无限制的撤消。) yum -y install vim #解决wget(非要说区别的话，curl由于可自定义各种请求参数所以在模拟web请求方面更擅长；wget由于支持ftp和Recursive所以在下载文件方面更擅长。类比的话curl是浏览器，而wget是迅雷9。) yum -y install wget #解决yum-config-manager命令找不到（使用yum-config-manager命令可以进行YUM配置管理） yum -y install yum-utils #常用软件 yum install wget vim yum-utils net-tools telnet nmap sysstat lrzsz dos2unix bind-utils -y 安装epel EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux. yum install epel-release 配置系统镜像源 镜像配置参考 考虑到镜像源可以多次配置，建议备份文件后加上年月日。 #0. 查看本地镜像源信息 cat /etc/yum.repos.d/CentOS-Base.repo #1. 备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup #2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ # CentOS 6 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo # 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo # CentOS 7 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo # CentOS 8 wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo # 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo #运行 yum makecache 生成缓存 yum makecache 升级内核 查看版本 #查看当前内核版本 uname -r #查看系统版本 cat /etc/redhat-release 启用 ELRepo 仓库 ELRepo 仓库是基于社区的用于企业级 Linux 仓库，提供对 RedHat Enterprise (RHEL) 和 其他基于 RHEL的 Linux 发行版（CentOS、Scientific、Fedora 等）的支持。 ELRepo 聚焦于和硬件相关的软件包，包括文件系统驱动、显卡驱动、网络驱动、声卡驱动和摄像头驱动等。 #导入ELRepo仓库的公共密钥 rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org #安装ELRepo仓库的yum源 #centos8 yum install https://www.elrepo.org/elrepo-release-8.el8.elrepo.noarch.rpm #centos7 yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm 查看可用的系统内核包 在https://www.kernel.org/上可以查看最新核心 yum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available 安装最新版本内核 yum --enablerepo=elrepo-kernel install kernel-ml --enablerepo 选项开启 CentOS 系统上的指定仓库。默认开启的是 elrepo，这里用 elrepo-kernel 替换。 启动后选择最新的内核版本 验证 uname -r 删除旧内核 #查看系统中全部的内核： rpm -qa | grep kernel #删除老内核以及内核工具 rpm -qa|grep kernel|grep 3.10 rpm -qa|grep kernel|grep 3.10|xargs yum remove -y 安装新版本工具包 yum --disablerepo=\\* --enablerepo=elrepo-kernel install -y kernel-ml-tools.x86_64 http://elrepo.org/tiki/tiki-index.php https://www.cnblogs.com/xzkzzz/p/9627658.html 常用命令 网络配置 #配置网卡信息 vim /etc/sysconfig/network-scripts/ifcfg-ens33 #重启网络服务 systemctl restart network #修改主机名 hostnamectl set-hostname #查看主机名 hostname 关闭SELinux 安全增强型 Linux（Security-Enhanced Linux）简称 SELinux，它是一个 Linux 内核模块，也是 Linux 的一个安全子系统。 SELinux 主要由美国国家安全局开发。2.6 及以上版本的 Linux 内核都已经集成了 SELinux 模块。 SELinux 的结构及配置非常复杂，而且有大量概念性的东西，要学精难度较大。很多 Linux 系统管理员嫌麻烦都把 SELinux 关闭了。 如果可以熟练掌握 SELinux 并正确运用，我觉得整个系统基本上可以到达\"坚不可摧\"的地步了（请永远记住没有绝对的安全）。 掌握 SELinux 的基本概念以及简单的配置方法是每个 Linux 系统管理员的必修课。 #将SELINUX=enforcing改为SELINUX=disabled vim etc/selinux/config #查看状态 getenforce 防火墙 #查看防火墙状态 systemctl status firewalld #停止防火墙 systemctl stop firewalld CentOS7 常用命令集合 启动一个服务：systemctl start nginx.service 关闭一个服务：systemctl stop postfix.service 重启一个服务：systemctl restart nginx.service 显示一个服务的状态：systemctl status postfix.service 在开机时启用一个服务：systemctl enable nginx.service 在开机时禁用一个服务：systemctl disable nginx.service 查看服务是否开机启动：systemctl is-enabled nginx.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed free -h 查看内存使用情况 df -hl 查看磁盘剩余空间 df -h 查看每个根路径的分区大小 du -sh [目录名] 返回该目录的大小 du -sm [文件夹] 返回该文件夹总M数 du -h [目录名] 查看指定文件夹下的所有文件大小（包含子文件夹） 查看硬盘的分区 #sudo fdisk -l 查看IDE硬盘信息 #sudo hdparm -i /dev/hda 查看STAT硬盘信息 #sudo hdparm -I /dev/sda 或 #sudo apt-get install blktool #sudo blktool /dev/sda id 查看硬盘剩余空间 #df -h #df -H 查看目录占用空间 #du -hs 目录名 优盘没法卸载 #sync fuser -km /media/usbdisk 疑问 su命令与su - 命令的区别 切换root身份不同 su命令：su只是切换了root身份，但Shell环境仍然是普通用户的Shell；而su -连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误，报command not found的错误。 su - 命令：su切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用su -命令切换以后，工作目录变成root的工作目录了。 采用su deploy命令后，取目标用户不同 su命令：su不会读取目标用户的环境配置文件，如图。 su - 命令：su - 读取目标用户的环境配置文件，如图。 综上总结：有“-”和无“-”各自的环境变量不同。 service命令 su命令：使用 su root 切换到root用户后，不可以使用service命令； su - 命令：使用 su - 后，就可以使用service命令了。 用echo $PATH命令后，环境量不同 su命令：环境量变为usr。 2、su - 命令：环境量变为oracle。 待整理或学习 Linux软件安装管理之——RPM与YUM详解 Docker&Docker-compose的安装 docker 简介 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 安装准备 切换至root用户&确认CentOS的内核&更新CentOS #切换至root su root #确认内核 uname -r #系统更新 yum update 添加docker的yum源管理配置 国内建议是阿里源，官方源为https://download.docker.com/linux/centos/docker-ce.repo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 查看docker-ce各个版本 yum list docker-ce --showduplicates|sort -r 安装docker-ce yum install docker-ce 命令不标注版本号，则按照last版本。（若安装不成功，请参考下一小节解决） Centos8提示错误信息 这个是要求提前安装必要的containerd.io yum list containerd.io --showduplicates|sort -r yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm 我们看到直接这样的查询containerd.io版本都低于必要版本（如果有当然更好，直接使用 yum install -y containerd.io 安装即可），所以我们要去看阿里镜像里最新的版本 https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/ 常用命令 查看版本：docker -v 查看镜像：docker images 查看容器：docker ps 启动 docker 服务：systemctl start docker 停止 docker 服务：systemctl stop docker 重启 docker 服务：systemctl restart docker 进入一个运行中的容器：docker exec -it xx /bin/bash (xx可以是Id也可以是Name) ※注：使用非root用户启用或链接docker会提示权限被拒绝，所以需要切换至root用户或者sudo或者按下面说明加入docker组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立docker组： sudo groupadd docker 将当前用户添加到docker组中：sudo usermod -aG docker $USER Docker-Compose安装 简介 Docker Compose是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。 安装（两种安装） 下载安装方式 通过 curl命令https://github.com/docker/compose/releases获取最新安装包。并将下载的文件通过chmod +x赋予可执行权限 #下载并解压，可以将下面命令的版本号替换成最新的即可直接使用 curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose #赋予可执行权限 chmod +x /usr/local/bin/docker-compose pip安装方式 https://www.cnblogs.com/felixqiang/p/11946644.html 验证安装 #测试安装 sudo docker-compose --version 详解Docker-Compose.yml文件 https://www.jianshu.com/p/ba77c7bdf03e 安装gitlab Docker安装gitlab 在DockerHub上搜索中文版本GitLab镜像 现在新版本gitlab新版官方已支持本地化（中文），所以不需要在pull非官方中文版本 https://hub.docker.com/ search gitlab/gitlab-ce Pull GitLab镜像到本地 使用docker-compose启动gitlab容器 在/usr/local/docker/gitlab/目录下创建 docker-compose.yml docker-compose.yml version: '3' services: gitlab: image: 'gitlab/gitlab-ce' #镜像名称 container_name: 'gitlab' #自定义容器名称 restart: unless-stopped hostname: '172.16.16.4' #内网地址 environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'http://182.61.150.130' gitlab_rails['gitlab_shell_shh_port'] = 2222 unicorn['port']=8888 nginx['listen_port']=80 gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] ='smtp.wo.cn' gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = '13048818693@wo.cn' gitlab_rails['smtp_password'] = '邮箱密码' gitlab_rails['smtp_domain'] = 'wo.cn' gitlab_rails['smtp_authentication'] = 'login' gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = true gitlab_rails['gitlab_email_from'] = '13048818693@wo.cn' gitlab_rails['gitlab_email_reply_to'] = '13048818693@wo.cn' ports: - '80:80' - '8443:443' - '2222:22' volumes: - /usr/local/docker/gitlab/config:/etc/gitlab - /usr/local/docker/gitlab/data:/var/opt/gitlab - /usr/local/docker/gitlab/logs:/var/log/gitlab deploy: resources: limits: memory: 1.5G reservations: memory: 0.5G 使用docker-compose up -d命令启动容器（建议修改配置后第一次启动使用docker-compose up启动 这样可以看到会不会报错） 测试邮件 附加 https://docs.gitlab.com/omnibus/settings/smtp.html https://docs.docker.com/compose/compose-file/ 免密登录 将tortoise git客户端的默认ssh客户修改成git目录下的ssh客户端 在git的bin目录下执行ssh-keygen -t rsa -C \"your_email@youremail.com\" 命令，一路回车，生成公钥C:\\Users\\Administrator.ssh\\id_rsa.pub文件 关于迁移或升级 Docker Gitlab数据迁移之备份恢复https://www.jianshu.com/p/e7c056d273b6 迁移 #进入docker容器，-it 参数后为容器Id(也可以是容器名称),可通过docker ps 获得 docker exec -it 69d13187445e /bin/bash #执行备份，备份文件会产生到/var/opt/gitlab/backups/ gitlab-rake gitlab:backup:create #查看gitlab版本（新的目标服务器gitlab版本必须与源服务的gitlab版本一直，不然会出现失败情况） cat /opt/gitlab/embedded/service/gitlab-rails/VERSION #将备份文件从容器中（也可以是容器名称）复制到宿主机的root目录下（也可以是任意目录） docker cp 69d13187445e:/var/opt/gitlab/backups/1590636450_2020_05_28_13.0.0_gitlab_backup.tar /root #在新服务器上将文件copy到目标的容器中(这里gitlab是容器名称) docker cp 1590636450_2020_05_28_13.0.0_gitlab_backup.tar gitlab:/var/opt/gitlab/backups/ #进入docker容器(这里gitlab是容器名称) docker exec -it gitlab /bin/bash #在容器中停止相关数据连接服务 gitlab-ctl stop unicorn gitlab-ctl stop sidekiq #备份文件搜权，必须是git用户所有者（用root下导入才需要） chown -R git:git /var/opt/gitlab/backups/1590636450_2020_05_28_13.0.0_gitlab_backup.tar #从1590636450_2020_05_28_13.0.0编号备份中恢复(这里gitlab是命令格式) gitlab-rake gitlab:backup:restore BACKUP=1590636450_2020_05_28_13.0.0 #启动Gitlab sudo gitlab-ctl start 暂未发现不覆盖会导致问题，gitlab.rb的配置部分已在docker-compose.yml内已配置。 升级 因为gitlab新旧版本之间数据库可能有变更，所以存在原版本升级到跨度比较大的版本，存在数据库升级失败的情况。为此建议升级前按迁移方式备份好数据。 https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations 我是从11.1.4升级的，升级路径为11.1.4→11.3.4→11.11.8→12.0.12→12.10.6→latest(13.0.0) 个人认为的基本原则是，当前版本，应对升级到当前大版本的最后一个版本，然后下一个大版本的起始小版本，同时参考官方给的指引。避免同一个大版本之间的小版本数据库也有较大的变化而不能兼容升级。 附加 Nexus Docker安装Nexus 用户的admin默认密码在docker-composer.yml映射路径的admin.password文件中,登录后就要求修改密码，文件就会被系统删除。 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 13:05:50 "},"database/mysql/db/":{"url":"database/mysql/db/","title":"MySQL","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 诞生与发展历程 安装更新卸载（引用使用移除） For Windows 下载 安装与启动 解压 初始化数据库 注册windows服务 卸载 安装注意事项 For CentOS8 在线安装 启动 配置 修改密码 开启远程访问 备份还原 常用语句 外键 查询数据库所有表名 新增字段 游标示例 查询数据表中数据记录 分组排序 高级知识点 主从复制 能解决的问题 配置 解决什么问题 MySQL 社区版本是免费开源的，其基本功能与企业版大致相同。其软件体积小，安装使用简单，并且易于维护。 诞生与发展历程 MySQL的历史最早可以追溯到1979年，那时Oracle也才小打小闹，微软的SQL Server影子都没有。Monty Widenius在其合伙的TcX小公司工作时，用BASIC设计了一个报表工具，可以在4M主频和16KB内在的计算机上运行。随着时间的推移，这个小工具被用C重写并迁移到Unix上运行。当时，它只是一个很底层的面向报表的存储引擎，再配上一个报表前端。它就是大家知道的Unireg。 1990年，该公司的客户急切要求访问其数据的SQL接口，TcX提出其中一方案是把数据都加载进一个商用数据库。但Monty对这个方案的执行速度并不满意。他尝试将mSQL的代码用做SQL层，并用自己的低层级的存储引擎集成进来，但效果也不好。于是, Monty决心自己重写一个SQL。 1996年，MySQL 1.0发布,只面向一小拨人。同年10月，MySQL 3.11.1发布，只提供了Solaris下的二进制版本。一个月后，Linux二进制包也发布。 此时的MySQL还非常简陋，除了在一个表上做一些Insert，Update，Delete和Select 操作，没有其他更多的功能。 接下来的两年里，MySQL依次移植到各个平台下。它发布时，采用的许可策略，有些与众不同：允许免费商用，但是不能将MySQL与自己的产品绑定在一起发布。如果想一起发布，就必须使用特殊许可，意味着要花银子。 MySQL3.22应该是一个标志性的版本，提供了基本的SQL支持。还带有一个复杂的优化器，新版本速度很快，且非常稳定。尽管如此，它还是不支持事务、子查询、外键、存储过程和视图，只存在表级别的锁。 1999-2000，一个名叫MySQL AB的独立公司成立了（Monty Widenius也作为创始人之一），它聘请了几位开发者并与Sleepycat公司建立合作伙伴关系，提供访问Berkeley DB数据文件的SQL接口。自从Berkeley DB具备事务功能之后，它就赋于了MySQL支持事务的特质，补上了它的短板。在为集成的Berkeley DB做了一些修改之后，MySQL 3.23发布了。 2000 年，MySQL 公布了自己的源代码，并采用GPL（GNU General Public License）许可协议，正式进入开源世界。 2000年4月，有了Slashdot的支持与赞助，master/slave机制加入。不支持事务的老存储引擎ISAM被重写了，并以MyISAM的形式发布。经过大量的改良，当前版本也支持了全文搜索。MySQL AB还曾有一个跟NuShpere短期的合作，在MySQL中加入了一个支持行级锁和事务的引擎Gemini，但因法律问题于2001年结束了。也就在这时，Heikki Tuuri提议用自己的引擎集成到其中，并接手MySQL AB的工作，这个引擎就是同样支持行级锁和事务的InnoDB。 2003年3月，MySQL 4.0正式发布。新增特性：除了MySQL/InnoDB组合，还有查询缓存(Query Cache)，优化器的改良，客户端/服务器间的协议用SSL加密。该引擎由Innobase公司开发，支持事务，支持行级锁，适用于OLTP等高并发场景。 2004年10月，MySQL 4.1发布，2005年10月发布里程碑的一个版本 5.0。4.1版本新增子查询，空间索引支持也加到了MyISAM引擎中。Unicode支持也被实现了。客户端/服务器协议也有了大量的改动，而且支持预处理语句（prepared statement）。5.0版本加入了存储过程，服务器端游标，触发器，视图，分布式事务（Xa transactions），查询优化器的显著改进以及其它的一些特性。MySQL的开发者发现如果要让4.1 稳定下就要花很大的工夫，如果他们要把4.1的新特性都加进去，就必须先搞定存储过程，所以他们痛下决心另创了一个分枝来开发5.0。经一度因这个造成了一些混乱——两个分枝同时处在alpha 阶段，后来4.1稳定了，这个尴尬也就随之而解了。2005年，Oracle收购Innobase公司。 在5.0 之后的版本里，MySQL明确地表现出迈向高性能数据库的发展步伐。5.1版本紧随其后，其中加了好多的新的改进，如表分区（table data partitioning），基于行的复制（row-based replication）,事件调度器（event schedular），和让新存储引擎和其它插件轻松集成的标准化插件API。 2008年1月16，Sun以10亿美金收购MySQL AB。同年，发布MySQL 5.1，其开始支持定时器（Event scheduler），分区，基于行的复制等特性。 2009年4月20，Oracle公司以74亿美元收购Sun公司，自此MySQL数据库进入Oracle时代。 2010年4月22，发布MySQL 5.5，其主要新特性包括半同步的复制及对SIGNAL/RESIGNAL的异常处理功能的支持，最重要的是InnoDB存储引擎终于变为当前MySQL的默认存储引擎。MySQL 5.5不是时隔两年后的一次简单的版本更新，而是加强了MySQL各个方面在企业级的特性。Oracle公司同时也承诺MySQL 5.5和未来版本仍是采用GPL授权的开源产品。同年发布MySQLcluster 7.1 ，MySQL Cluster 是MySQL适合于分布式计算环境的高实用、高冗余版本。它采用了NDB Cluster 存储引擎，允许在1个 Cluster 中运行多个MySQL服务器。在MySQL 5.0及以上的二进制版本中、以及与最新的Linux版本兼容的RPM中提供了该存储引擎。（注意，要想获得MySQL Cluster 的功能，必须安装 mysql-server 和 mysql-max RPM） 2011年4月，MySQL 5.6发布，作为被Oracle收购后，第一个正式发布并做了大量变更的版本（5.5版本主要是对社区开发的功能的集成），对复制模式，优化器等做了大量的变更，其中最重要的主从GTID复制模式，大大降低了MySQL高可用操作的复杂性，除此之外，由于对源代码进行了大量的调整，到2013年，5.6版本才正式GA。 2013年4月，5.6版本GA后，新特性的变更，开始作为独立的5.7分支进行进一步开发，在并行控制，并行复制等方面，进行了大量的优化调整，正式GA于2015年10月份，这个版本也是到目前为止的，最新的稳定版本分支。 2016年9月，Oracle决定跳过MySQL 5.x命名系列，并抛弃之前的MYSQL 6，7两个分支（从来没有对外发布的两个分支），直接进入MySQL 8版本命名，也就是MySQL 8.0版本的开发。 最后，看看下面这个表格，表中给出了最近几个大版本的发布时间，及截止到本书出版，其最新的小版本及其发布时间。 | 版本 | GA时间 | 最新的小版本 | 最新小版本的发布时间 | 产品支持的结束时间 | | :--: | :--------: | :----------: | :------------------: | :----------------: | | 5.1 | 2008-11-14 | 5.1.73 | 2013-12-03 | 2013-12 | | 5.5 | 2010-12-03 | 5.5.61 | 2018-07-27 | 2018-12 | | 5.6 | 2013-02-05 | 5.6.41 | 2018-07-27 | 2021-02 | | 5.7 | 2015-10-21 | 5.7.23 | 2018-07-27 | 2023-10 | | 8.0 | 2018-04-19 | 8.0.12 | 2018-07-27 | 2026-04 | 从表中的数据来看， 大概每3年会发布一个大的版本。 产品的支持周期一般是8年。 以为MySQL 5.5是老古董了，但官方仍然在不断更新。 安装更新卸载（引用使用移除） For Windows 下载 https://dev.mysql.com/downloads/mysql/ 注意：官方网站随时可能改版，请找到关于MySQL Community下载页面，就可以下载最新版 安装与启动 解压 下载后的安装包，进行解压缩，在根目录中创建my.ini配置文件（文件编码必须是ANSI） 8.0版本 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3308 # 设置mysql数据库的数据的存放目录（可以是绝对路径，也可以是相对路径） datadir=data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 5.7版本 [mysql] # 设置 mysql 客户端默认字符集 default-character-set=utf8 [mysqld] #设置 3306 端口 port = 3306 # 设置mysql数据库的数据的存放目录（可以是绝对路径，也可以是相对路径） datadir=data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为 8 比特编码的 latin1 字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 定义了 mysql 应该支持的 sql 语法，数据校验等！ sql_mode=\"STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER\" #限制 server 接受的数据包大小 max_allowed_packet=1G 初始化数据库 #初始并获取密码： mysqld --initialize #初始无密码： mysqld --initialize-insecure 注册windows服务 在bin目录中进行下列命令进行安装或移除 #将MySQL注册成名称为mysql8为windows，故名称可自己按需定义 #服务安装： mysqld -install mysql8 #服务移除： mysqld --remove mysql8 #通过net启停服务（net系统命令，可在任意目录操作） #启动服务 net start mysql8 #停止服务 net stop mysql8 卸载 移除注册的windows服务即为卸载 安装注意事项 如果注册服务时出现左图错误，请下载 Visual C++ Redistributable Packages for Visual Studio 2013进行安装即可。下载地址为 https://www.microsoft.com/zh-CN/download/details.aspx?id=40784。 For CentOS8 在线安装 yum install mysql-server 启动 systemctl start mysqld #开机启动 systemctl enable mysqld 安装后密码为空，端口3306，如果需要修改配置，请操作/etc/my.cnf.d配置文件。 配置 修改密码 -- 8.0.4 以前： set password for 'root'@'localhost'=password('root'); -- 8.0.4 以后： ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root'; -- 修改完密码后，退出重新登录，进行开启远程操作 开启远程访问 use mysql; -- 更新 root 用户,允许任何 IP 登录 update user set host ='%' where user ='root'; -- 授权 root 用户拥有数据服务器所有数据库的所有权限 -- 5.7 grant all privileges on *.* to 'root'@'%' identified by \"root\"; -- 8.0 grant all privileges on *.* to 'root'@'%'; -- 刷新权限 flush privileges; 备份还原 -- 备份： mysqldump -uroot -p123456 –ER -i csust > d:\\csust.sql -- 还原： mysql -uroot -p --default-character-set=utf8 –c csust 常用语句 外键 当MySQL中设置了foreign key关联，造成无法更新或删除数据。可以通过设置FOREIGN_KEY_CHECKS变量来避免这种情况。 -- 禁用外键约束 SET FOREIGN_KEY_CHECKS = 0; -- 启动外键约束 SET FOREIGN_KEY_CHECKS = 1; -- 查看当前FOREIGN_KEY_CHECKS的值 SELECT @@FOREIGN_KEY_CHECKS; 查询数据库所有表名 select table_name from information_schema.tables where table_schema='' and table_type='basetable' and table_name='' and table_rows!=0; 新增字段 -- 新增字段前，判断字段是否存在当前表中 DROP PROCEDURE IF EXISTS add_col_homework; DELIMITER $$ CREATE PROCEDURE add_col_homework () BEGIN SET @tableName='qas_e_organization'; SET @talbeColumn='Path'; SET @talbeColumnType='varchar(255)'; SET @talbeColumnComment='组织机构路径（用“,”间隔父级与子级机构码）'; IF not EXISTS(SELECT * FROM information_schema.columns WHERE (column_name =@talbeColumn AND TABLE_NAME = @tableName AND TABLE_SCHEMA IN (SELECT DATABASE()))) THEN set @vSql=CONCAT('ALTER TABLE ',@tableName,' ADD COLUMN ',@talbeColumn,' ',@talbeColumnType,' CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT ''', @talbeColumnComment,''''); PREPARE stmt FROM @vSql; EXECUTE stmt; DEALLOCATE PREPARE stmt; END IF; END$$ DELIMITER ; CALL add_col_homework(); DROP PROCEDURE IF EXISTS add_col_homework; 游标示例 -- 通过游标赋值 DROP PROCEDURE IF EXISTS setOrgPath ; DELIMITER $$ CREATE PROCEDURE setOrgPath () BEGIN DECLARE my_id VARCHAR (50);-- 自定义变量 1 DECLARE my_parentid VARCHAR (50);-- 自定义变量 2 DECLARE this_parentid VARCHAR (50);-- 自定义变量 2 DECLARE my_path VARCHAR (200);-- 自定义变量 3 DECLARE done INT DEFAULT FALSE; -- 自定义控制游标循环变量,默认 false DECLARE My_Cursor CURSOR FOR (SELECT id,parentid,orgcode FROM qas_e_organization);-- 定义游标并输入结果集 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;-- 绑定控制变量到游标,游标循环结束自动转 true OPEN My_Cursor;-- 打开游标 myLoop :LOOP-- 开始循环体,myLoop 为自定义循环名,结束循环时用到 FETCH My_Cursor INTO my_id,my_parentid,my_path;-- 将游标当前读取行的数据顺序赋予自定义变量 12 IF done THEN -- 判断是否继续循环 LEAVE myLoop;-- 结束循环 END IF; -- 自己要做的事情,在 sql 中直接使用自定义变量即可 SET this_parentid = my_parentid; WHILE LENGTH(IFNULL(this_parentid, '')) > 0 DO SELECT parentid,CONCAT(orgcode, ',', my_path) INTO this_parentid,my_path FROM qas_e_organization WHERE id = this_parentid; END WHILE; UPDATE qas_e_organization SET path = my_path WHERE id = my_id; COMMIT;-- 提交事务 -- 自己要做的事情结束 END LOOP myLoop;-- 结束自定义循环体 CLOSE My_Cursor;-- 关闭游标 END$$ DELIMITER ; CALL setOrgPath (); DROP PROCEDURE IF EXISTS setOrgPath ; 查询数据表中数据记录 DELIMITER ;; DROP PROCEDURE IF EXISTS `statis_rows`; CREATE PROCEDURE statis_rows (IN v_schema VARCHAR(50)) BEGIN DECLARE sql_str VARCHAR(5000); DECLARE no_more_departments INTEGER DEFAULT 0; DECLARE sql_cur CURSOR FOR (SELECT CONCAT('select ',\"'\",table_schema,\"'\",\",'\",table_name,\"',\",'count(1)',', ''',TABLE_COMMENT,''' ',' into @v_tab_schema,@v_tab_name,@v_count,@v_comment from `',TABLE_SCHEMA,'` .',TABLE_NAME,'') FROM information_schema.TABLES WHERE table_schema = v_schema AND table_type='base table' and TABLE_NAME!='v_table_rows' ); DECLARE CONTINUE HANDLER FOR NOT FOUND SET no_more_departments = 1; DROP TABLE IF EXISTS `v_table_rows`; CREATE TABLE `v_table_rows` ( `v_tab_schema` varchar(255) DEFAULT NULL COMMENT '数据库名称', `v_tab_name` varchar(255) DEFAULT NULL COMMENT '表名', `v_count` varchar(255) DEFAULT NULL COMMENT '记录数', `v_sysdate` datetime DEFAULT NULL COMMENT '数据记录属统计时间', `v_comment` varchar(255) DEFAULT NULL COMMENT '表注释' ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='数据库表记录数据条数'; OPEN sql_cur; myLoop: LOOP FETCH sql_cur INTO sql_str; IF no_more_departments = 1 THEN LEAVE myLoop; END IF; SET @v_sql = sql_str; PREPARE stmt FROM @v_sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; INSERT INTO v_table_rows VALUES (@v_tab_schema, @v_tab_name, @v_count, sysdate(),@v_comment); END LOOP myLoop; CLOSE sql_cur; select v_tab_schema '数据库名称',v_tab_name '表名',`v_count` '记录数',`v_sysdate` '数据记录属统计时间',v_comment '表注释' from v_table_rows ORDER BY v_tab_schema,v_tab_name,v_count ; drop TABLE v_table_rows; END;; DELIMITER ; call statis_rows('qas_mxzy'); DROP PROCEDURE IF EXISTS statis_rows; 分组排序 SELECT id, rank FROM ( SELECT id, @rownum :=@rownum + 1, IF ( @examid = examid AND @classid = classid, IF ( @score = score ,@rank ,@rank :=@rank + 1 ) ,@rank := 1 ) AS rank, @examid := examid, @classid := classid, @score := score FROM ( SELECT st.id, st.studentid, st.score, sc.classid, ST.examid FROM yk_student_exam st LEFT JOIN yk_studentclass sc ON ST.studentid = sc.studentid WHERE ST. STATUS = 3 AND examid = 50 ORDER BY examid ASC, classid ASC, score DESC ) student_exam, ( SELECT @rownum := 0, @examid := NULL ,@classid := NULL ,@score = NULL ,@rank := 0 ) temp ) result 高级知识点 主从复制 能解决的问题 备份数据 读写分离 配置 两个数据库，必须分开在两台服务器，即使是为了自己实验测试。 主服务器my.ini [mysqld] #设置服务器id，为1表示主服务器,实例唯一ID，不能和canal的slaveId重复 server-id=1 #注意log-bin配置的是日志文件名前缀路径，日志文件在datadir生成 log-bin=mysql-bin #选择mixed模式 binlog-format=mixed #需要同步的数据库名，如果有多个数据库，可重复此参数，每个数据库一行 binlog-do-db=test create user 'master'@'%' identified with mysql_native_password by 'pass'; GRANT REPLICATION SLAVE ON *.* TO 'master'@'%'; flush privileges; show master status; 从服务my.ini [mysqld] server-id=2 #与主服务器相同 log-bin=master-1-mysql-bin #与主服务器相同 binlog-format=mixed #与主服务器相同 replicate-do-db=test stop slave; change master to master_host='127.0.0.1', master_port=3308,master_user='master',master_password='pass',master_log_file='master-1-mysql-bin.000001',master_log_pos=2335; start slave; show slave status\\G; Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2020-11-27 22:14:29 "},"dev/python/":{"url":"dev/python/","title":"Python开发环境","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 前言 Python 简介 在Window环境下安装 在CentOS环境下安装 安装 为什么要初始准备安装 Q:问题一(关于gcc) Q:问题二(关于ssl) Q:问题三（关于zlib） Q:问题四（关于make） Python库镜像加速 常见问题 python运行时目录 %matplotlib作用 Jupyter Notebook 简介 安装 插件扩展 扩展 markdown目录 前言 Python是一种跨平台的 计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。 很多人建议使用Anaconda包，将所有的Python环境安装好。但我不建议，因为我们初学者，要愿意折腾才知道，环境与环境的关联。如果是生产环境，我建议用Anaconda，因为我们保证生产环境的安全。 Anaconda介绍、安装及使用教程，有兴趣的可以通过这篇文章了解。 Python 简介 CentOS7默认安装了Python 2.7.5，因Python 2和Python3语法差别有一定的改变，所以我们需要在系统中安装Python3。在系统中可以同时存在Python2和Python3，且为了兼容Python2的程序，我们在安装Python3的同时，保留Python2。 几乎所有的Python 2程序都需要一些修改才能正常地运行在Python 3的环境下。为了简化这个转换过程，Python 3自带了一个叫做2to3的实用脚本(Utility Script)，这个脚本会将你的Python 2程序源文件作为输入，然后自动将其转换到Python 3的形式。案例研究:将chardet移植到Python 3(porting chardet to Python 3)描述了如何运行这个脚本，然后展示了一些它不能自动修复的情况。这篇附录描述了它能够自动修复的内容。 python2 与 python3 语法区别 在Window环境下安装 暂略 python -m pip install --upgrade pip -i https://pypi.douban.com/simple 在CentOS环境下安装 安装 为什么不直接用yum安装Python，是因为pip3需要单独安装 获取Python官方下载地址 https://www.python.org/downloads/ #初始准备安装（关于此安装解疑请参考下一节“为什么要初始准备安装”） yum -y install gcc openssl openssl-devel zlib zlib-devel make #下载 wget https://www.python.org/ftp/python/3.8.2/Python-3.8.2.tar.xz #解压 tar -xvJf Python-3.8.2.tar.xz #创建编译安装目录 mkdir /usr/local/python3 #安装 cd Python-3.8.2 ./configure --prefix=/usr/local/python3 --enable-optimizations --with-ssl #第一个指定安装的路径,不指定的话,安装过程中可能软件所需要的文件复制到其他不同目录,删除软件很不方便,复制软件也不方便. #第二个可以提高python10%-20%代码运行速度. #第三个是为了安装pip需要用到ssl,后面报错会有提到. #编译和安装 make && make install #创建软链接 ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3 ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3 #验证是否成功 python3 -V pip3 -V #安装相应的编译工具(在root用户下(不要用普通用户,麻烦),全部复制粘贴过去,一次性安装即可.) yum -y groupinstall \"Development tools\" yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel yum install -y libffi-devel zlib1g-dev yum install zlib* -y 上面这段请勿执行，因为我们不需要所有的编译工具，按下面的命令执行就可以了。 安装Python3参考 configure、make 和 make install 的区别 为什么要初始准备安装 Q:问题一(关于gcc) A:解决方式 #安装C编译器gcc(GNU编译器套件) yum -y install gcc Q:问题二(关于ssl) A:解决方式： yum install openssl openssl-devel Q:问题三（关于zlib） A:解决方式： yum install zlib zlib-devel Q:问题四（关于make） A:解决方式： yum install make Python库镜像加速 pip国内的一些镜像   阿里云 http://mirrors.aliyun.com/pypi/simple/   中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/   豆瓣(douban) http://pypi.douban.com/simple/   清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/   中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 修改源方法：   临时使用：     可以在使用pip的时候在后面加上-i参数，指定pip源     eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple   永久修改：     linux:       修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple windows: 直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，在pip 目录下新建文件pip.ini，内容如下 或者按照网友的建议：win+R 打开用户目录%HOMEPATH%，在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.ini 文件, 内容如下 [global] timeout = 6000 index-url = https://pypi.tuna.tsinghua.edu.cn/simple trusted-host = pypi.tuna.tsinghua.edu.cn 常见问题 python运行时目录 运行时目录是当前用户目录 import os path1=os.path.abspath('.') # 表示当前所处的文件夹的绝对路径 print(path1) path2=os.path.abspath('..') # 表示当前所处的文件夹上一级文件夹的绝对路径 print(path2) import os,sys os.chdir(os.path.dirname(sys.argv[0])) %matplotlib作用 是在使用jupyter notebook 或者 jupyter qtconsole的时候，才会经常用到%matplotlib，也就是说那一份代码可能就是别人使用jupyter notebook 或者 jupyter qtconsole进行编辑的。关于jupyter notebook是什么，可以参考这个链接：[Jupyter Notebook介绍、安装及使用教程][1] 而%matplotlib具体作用是当你调用matplotlib.pyplot的绘图函数plot()进行绘图的时候，或者生成一个figure画布的时候，可以直接在你的python console里面生成图像。 Jupyter Notebook 简介 Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。 Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。 安装 参考安装 安装Jupyter Notebook的前提是需要安装了Python（3.3版本及以上，或2.7版本）。 #升级pip pip3 install --upgrade pip #安装jupyter pip3 install jupyter #启动 jupyter notebook # 后台运行启动 nohup jupyter notebook --allow-root > jupyter.log 2>&1 & Jupyter Notebook介绍、安装及使用教程 开机启动 配置：/root/.jupyter/jupyter_notebook_config.py ps -ef | grep jupyter kill -s 9 pid 插件扩展 扩展 #安装jupyter扩展 pip install jupyter_contrib_nbextensions #将jupyter插件集成至jupyter中(个人之这么理解的) jupyter contrib nbextension install --user --skip-running-check markdown目录 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 13:00:27 "},"dev/java/":{"url":"dev/java/","title":"Java开发环境","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Java的作者 前言 诞生 java发展史 java 背景 Java的作者 james gosling（詹姆斯.高斯林)，1955年5月19日出生于加拿大，Java编程语言的共同创始人之一，一般公认他为“Java之父”。 前言 自1946年2月14日世界上首款计算机ENAC问世，第一代计算机语言“机器语言”便诞生了，它使用的是最原始的穿孔卡片，这种卡片上使用的语言只有专家才能理解，与人类语言差别极大。这种语言本质上是计算机能识别的唯一语言，人类很难理解。为了能让人们更容易理解并编写，于是便有了第二代的“汇编语言”，相比机器语言，汇编语言大大前进了一步，尽管它还是太复杂，人们在使用时很容易出错误，但毕竟许多数码已经开始用字母来代替。简单的“0、1”数码谁也不会理解，但字母是人们能够阅读并拼写的。虽然第二代计算机语言仍然是“面向机器”的语言，但它已注定成为机器语言向更高级语言进化的桥梁。当计算机语言发展到第三代时，就进入了“面向人类”的语言阶段。你可以阅读、并直接用人类的语言来输入。对我们汉语来说，目前还不能用中文汉字来输入指令，这主要是因为中文的输入还没有一个非常好的手段。第三代语言被人们称之为“高级语言”。高级语言是一种接近于人们使用习惯的程序设计语言。它允许用英文写计算程序，程序中所使用的运算符号和运算公式，都和我们日常用的数学公式差不多。高级语言容易学习，通用性强，书写出的程序比较短，便于推广和交流，是很理想的一种程序设计语言。我们学习的就是第三代语言“高级语言“中的Java语言。 诞生 ​ 20世纪90年代，硬件领域出现了单片机式计算机系统，这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品（例如：电视机顶盒、面包烤箱、移动电话等）的智能化进度。Sun公司为了抢占先机，在1991年成立了一个名为“Green”（类似于绿色软件的意思）的项目小组，James Gosling、Patrick Naughton、Michael Sheridan和其他几个同事们一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面开始研究开发新技术，专攻计算机语言在消费类电子产品上嵌入式应用。 　　由于C++所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++所编写的程序过于庞大和复杂。另外由于消费类电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序跨平台运行也是个难题。为了解决困难，他们首先着眼于计算机语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后，能有半导体芯片生产商开发和生产这种硬件平台。对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了C++上的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发出了一个名为“Oak”的面向对象语言。 　　由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在己有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有太大区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak程序设计语言、类库和其硬件，以说服他们对Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还是一无所知的情况下就贸然生产硬件产品的风险实在是太大了，所以Oak语言也就因此缺乏硬件的支持而无法进入市场，从而被搁置了下来。 　　1994年6、7月间，在经历了一场历时三天的讨论后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网上。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，Patrick Naughton编写了一个小型万维网浏览器WebRunner。 　　1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态页面能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大IT企业为此纷纷投入了巨大的人力、物力与财力。这个时候，Sun公司想起了那个被搁置很久的Oak，并且重新审视了那个用软件编写的实验平台，由于它是按照嵌入式系统硬件平台体系结构所进行编写的，所以非常小，特色适用于网络上传输，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输Applet（一种将小程序嵌入到网页中进行执行的技术），并将Oak更名为“Java”。从此一个即好听又好记、具有强大的生命力的编程语言Java便诞生了。 　　（在申请商标的时候也有这样一件趣事，Sun公司在申请Oak商标时发现Oak已经被别家公司使用了，所以James Gosling决定通过市场部门，请来了一个命名顾问，召开命名征集会。在命名征集会上，大家提出了很多名字。最后按大家的评选次序，将十几个名字排列成表，上报给商标律师。排在第一位的是Silk（丝绸）。尽管大家都喜欢这个名字，但遭到James Gosling的坚决反对而作罢。排在第二和第三的都没有通过律师这一关。James Gosling最喜欢的就是排在第三位的Lyric（抒情诗）。只有排在第四位的名字得到了所有人的认可和律师的通过，这个名字就是“Java”。那么是谁在命名征集会上提议叫“Java”的呢?Jame Gosling在接受采访时回忆道：“市场部组织了命名会，命名顾问主持了会议，我们喊叫着列出了一大堆名字。我记得第一个提议Java这个名字的是Mark Opperman”。Mark Opperman是在一家名叫“爪蛙咖啡”的咖啡店与同事品尝咖啡时得到灵感的。Java是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。国外的许多咖啡店用Java来命名或宣传，以彰显其咖啡的品质。Java语言中的许多库类名称，多与咖啡有关，如JavaBeans（咖啡豆）、NetBeans（网络豆）以及ObjectBeans （对象豆）等等。） java发展史 ​ 1990年初，最初被命名为Oak； ​ 1995年5月23日，Java语言诞生，Sun在Sun World会议上正式发布Java语言和HotJava浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和Microsoft等各大公司都纷纷停止了自己的相关开发项目，竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台； ​ 1996年1月，第一个JDK-JDK1.0诞生，Sun公司发布了Java的第一个开发工具包（JDK1.0），这是Java发展历程中的重要里程碑，标志着Java成为一种独立的开发工具； ​ 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术； ​ 1996年9月，约8.3万个网页应用了Java技术来制作； ​ 1996年10月，Sun公司发布了Java平台第一个即时编译器（JIT）； ​ 1997年2月18日，JDK1.1发布，在随后的三周时间里，达到了22万次的下载量； ​ 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录； ​ 1997年9月，JavaDeveloperConnection社区成员超过十万； ​ 1998年2月，JDK1.1被下载超过2,000,000次； ​ 1998年12月8日，Java 2企业平台J2EE发布； ​ 1999年6月，SUN公司发布Java三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）； ​ 2000年5月8日，JDK1.3发布； ​ 2000年5月29日，JDK1.4发布，获得Apple公司Mac OS的工业标准的支持； ​ 2001年6月5日，Nokia宣布到2003年将出售1亿部支持Java的手机； ​ 2001年9月24日，J2EE1.3发布； ​ 2002年2月26日，J2SE1.4发布，此后Java的计算能力有了大幅提升，与J2SE1.3相比，其多了近62%的类与接口。在这些新特性当中，还提供了广泛的XML支持、安全套接字（Socket）支持（通过SSL与TLS协议）、全新的I/OAPI、正则表达式、日历与断言； ​ 2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，为了表示这个版本的重要性，J2SE 1.5正式更名为Java SE 5.0（内部版本号：1.5.0），代号“Tiger”该版本是自1996年发布1.0版本以来最大的更新，其中包括泛型的支持、基本数据类型的自动装箱、改进的循环、枚举类型、格式化I/O及可变参数； ​ 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME； ​ 2006年12月，SUN公司发布JRE6.0； ​ 2008年，SUN公司收购mysql； ​ 2009年4月20日，Oracle宣布将以每股9.5美元的价格收购Sun，该交易的总价值约为74亿美元。但Oracle通过收购Sun公司获得了两项软件资产：Java和Solaris。于是曾经代表一个时代的公司：Sun倒下了，不过Java的大旗依然“猎猎”作响。2007年11月，Google宣布推出一款基于Linux平台的开源手机操作系统：Android。Android的出现顺应了即将出现的移动互联网潮流，而且Android系统的用户体验非常好，因此迅速成为手机操作系统的中坚力量。Android平台使用了Dalvik虚拟机来运行.dex文件，Dalvik虚拟机的作用类似于JVM虚拟机，只是它并未遵守JVM规范而已。Android使用Java语言来开发应用程序，这也给了Java语言一个新的机会。在过去的岁月中，Java语言作为服务器端编程语言，已经取得了极大地成功；而Android平台的流行，则让Java语言获得了在客户端程序上大展拳脚的机会； ​ 2010年11月 由于甲骨文对Java社区的不友善，因此Apache扬言将退出JCP ​ 2011年7月28日甲骨文发布Java SE 7，，这次版本升级经过了将近5年时间。Java 7也是Oracle发布的第一个Java版本，引入了二进制整数、支持字符串的switch语句、菱形语法、多异常捕捉、自动关闭资源的try语句等新特性。 ​ 2014年3月18日 甲骨文发表Java SE 8，这次版本升级为Java带来了全新的Lambda表达式。除此之外，Java 8还增加了大量新特性，这些新特性使得Java变得更加强大。 ​ 2017年9月22日 甲骨文发表Java SE 9，该版本支持：模块化（jiqsaw）、交互式命令行（JShell）、默认垃圾回收期切换为G1、进程操作改进、竞争锁性能优化、分段代码缓存和优化字符串占用空间等新特性。 ​ 2018年3月21日 甲骨文发表Java SE 10 ​ 2018年9月26日 甲骨文发表Java SE 11 ​ 2019年3月19日 甲骨文发表Java SE 12 ​ 2019年9月17日 Java SE 13 Text Blocks (Preview) ​ 2020 3月18日 java14 正式发布 目前Java的版本已经更新到14版本，但市场主流还是使用的JDK8。 springcloud https://mvnrepository.com/ springboot和springcloud版本对应关系 打开pom.xml，鼠标右击选择\"Add as Maven Project\" 即可 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 12:56:03 "},"dev/nodejs/":{"url":"dev/nodejs/","title":"NodeJS开发","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 简介 Windows环境中下载与安装 下载 安装 验证安装 npm 镜像配置 环境配置 全局目录 缓存目录 自定义目录 环境变量 NODE_PATH配置 测试 常用命令 npx yarn Yarn是什么？ Yarn的优点？ Yarn和npm命令对比 npm的未来：npm5.0 简介 1.Node.js是一个JavaScript运行时环境（可以解析和执行JavaScript代码） 2.现在的JavaScript可以完全脱离浏览器来运行，一切都归功于Node.js 3.浏览器中的JavaScript包括EcmaScript、BOM、DOM 4.Node.js中的JavaScript ：没有BOM、DOM，用EcmaScript进行编码，主要是在Node这个JavaScript执行环境中为JavaScript提供一些服务器级别的API操作（例如文件读写、网络服务的构建、网络通信、http服务器等处理） 5.Node.js特性是 使用事件驱动、非阻塞IO模型(异步)，使得其轻量和高效 6.npm是基于Node.js开发出来的包管理工具，npm是世界上最大的开源库生态系统，绝大多数js相关的包都存放在npm上，方便开发人员下载使用 7.Google Chrome的V8引擎是目前公认的解析执行JavaScript代码最快的，Node.js构建在Google Chrome的V8引擎之上，是一个独立的JavaScript运行时环境 8.Node.js能做的事：Web服务器后台、命令行工具(npm、git、hexo) Windows环境中下载与安装 下载 在官方下载页面https://nodejs.org/en/download/，进行下载最新版本。产品开发建议使用LTS 安装 验证安装 npm 镜像配置 我们要知道node.js是一个JavaScript运行时环境，那我们做开发时，必然需要引用到第三方的组件包。这时候，我们就需要用到一个管理第三方组件包管理工具npm。Node.js已自带npm，安装Node.js时会一并安装，方便对第三方包的安装、升级与移除等管理。 既然npm对第三方组件包的进行安装，必然需要访问官方远端仓库下载包。然而npm默认仓库是国外，可想而知网络问题势必对安装有严重的影响。这时阿里造福，在国内构建了镜像源，方便我们程序员。 官方说明npm.taobao.org这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。 #查看已配置的地址 npm config get registry #设置为淘宝镜像(http://registry.npmjs.org ) npm config set registry https://registry.npm.taobao.org #设置回官方默认仓库源地址： npm config set registry https://registry.npmjs.org 如果你想在==保留==官方源的同时，又想==随时==使用淘宝源。你可以使用下面两种方法： #一、在命令后添加仓库源参数 npm install -g [包名] --registry=https://registry.npm.taobao.org #二、安装cnpm，需要使用淘宝源时，用cnpm代替npm执行命令 npm install -g cnpm --registry=https://registry.npm.taobao.org 环境配置 全局目录 在上一小节中你应该看到安装cnpm的命令中有一个-g参数，这个参数代表全局安装。如果把这个参数移除，则只会安装都当前目录下。 默认的全局安装路径，可以通过下面命令获取： npm config get prefix 全局组件包，都会安装到，该目录中。 缓存目录 既然包可以全局安装和当前目录安装，那==不同目录下，安装相同的包==，那岂不是每次都要从仓库下载？非也。npm为我们提供了一个==缓存目录==，所有通过npm安装的包都会缓存在此文件夹。这样npm安装包时，首先会在缓存目录判断是否已经存在，若不存在，再进行网络下载。 默认的缓存路径，可以通过下面命令获取： npm config get cache 自定义目录 一般情况下，以上两个目录建议都设置到非系统盘当中区。下面是我设置的路径： # 设置全局模块 npm config set prefix \"D:\\Repository\\nodejs\\npm\\node_global\" # 设置缓存路径 npm config set cache \"D:\\Repository\\nodejs\\npm\\node_cache\" 环境变量 若你修改了全局目录，则需要重新设置环境变量。反之，则不需要。全局安装的命令，能随时得到执行，是因为全局路径配置在了环境变量中。所以我们需要将原路径修改成新的路径。 接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量” 将【用户变量】下的【Path】修改为【D:\\Repository\\nodejs\\npm\\node_global】 NODE_PATH配置 nodejs 中的 NODE_PATH - 大智若简 - 博客园 (cnblogs.com) 在【系统变量】下新建【NODE_PATH】，输入【D:\\Repository\\nodejs\\npm\\node_global\\node_modules】 测试 配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，输入如下命令进行模块的全局安装： npm install express -g # -g是全局安装的意思 常用命令 NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用 #npm-check检查更新 npm install -g npm-check npm-check #npm-upgrade更新 npm install -g npm-upgrade npm-upgrade #更新全局包： npm update -g #更新生产环境依赖包： npm update --save #更新开发环境依赖包： npm update --save-dev npm install -g npm npx Node.js中npx命令的使用方法、场景 - 虚伪渲染敷衍 - 博客园 (cnblogs.com) npx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，指在提高从npm注册表使用软件包时的体验 ，npm使得它非常容易地安装和管理托管在注册表上的依赖项，npx使得使用CLI工具和其他托管在注册表。它大大简化了一些事情。 就像npm极大地提升了我们安装和管理包依赖的体验，在npm的基础之上，npx让npm包中的命令行工具和其他可执行文件在使用上变得更加简单。它极大地简化了我们之前使用纯粹的npm时所需要的大量步骤。 主要特点： 1、临时安装可执行依赖包，不用全局安装，不用担心长期的污染。 2、可以执行依赖包中的命令，安装完成自动运行。 3、自动加载node_modules中依赖包，不用指定$PATH。 4、可以指定node版本、命令的版本，解决了不同项目使用不同版本的命令的问题。 yarn Yarn是什么？ “Yarn是由Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 ，正如官方文档中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的。”这句话让我想起了使用npm时的坑了： npm install的时候巨慢。特别是新的项目拉下来要等半天，删除node_modules，重新install的时候依旧如此。 同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不同的含义。 \"5.0.3\", \"~5.0.3\", \"^5.0.3\" “5.0.3”表示安装指定的5.0.3版本，“～5.0.3”表示安装5.0.X中最新的版本，“^5.0.3”表示安装5.X.X中最新的版本。这就麻烦了，常常会出现同一个项目，有的同事是OK的，有的同事会由于安装的版本不一致出现bug。 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。 带着这些坑，我开始了解Yarn的优势及其解决的问题。 Yarn的优点？ 速度快 。速度快主要来自以下两个方面： 并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。 安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。 更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。 多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。 更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。 Yarn和npm命令对比 npm yarn npm install yarn npm install react --save yarn add react npm uninstall react --save yarn remove react npm install react --save-dev yarn add react --dev npm update --save yarn upgrade npm的未来：npm5.0 有了yarn的压力之后，npm做了一些类似的改进。 默认新增了类似yarn.lock的 package-lock.json； git 依赖支持优化：这个特性在需要安装大量内部项目（例如在没有自建源的内网开发），或需要使用某些依赖的未发布版本时很有用。在这之前可能需要使用指定 commit_id 的方式来控制版本。 文件依赖优化：在之前的版本，如果将本地目录作为依赖来安装，将会把文件目录作为副本拷贝到 node_modules 中。而在 npm5 中，将改为使用创建 symlinks 的方式来实现（使用本地 tarball 包除外），而不再执行文件拷贝。这将会提升安装速度。目前yarn还不支持。 Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 18:41:25 "},"cicd/java/":{"url":"cicd/java/","title":"Java自动构建","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 SpringBoot 【构建】服务器环境安装 JDK下载与安装 maven下载与安装 下载解压版 配置环境变量 配置阿里maven仓库 Jenkins相关插件安装和配置 插件 JDK配置 Maven配置 ssh配置 【测试】服务器环境安装 JDK下载与安装 JDK下载与配置 FreeSSHd下载与安装 FreeSSHd下载与配置 Nginx下载与配置 建立构建任务 建立项目和配置SVN文件获取 项目文件生成 将文件上传至测试服务器并执行批处理操作 批处理文件 SpringBoot 【构建】服务器环境安装 JDK下载与安装 JDK最新版本下载地址 将下载好后的文件进行解压缩 maven下载与安装 下载解压版 maven最新版下载 将下载好后的文件进行解压缩 配置环境变量 配置 配置阿里maven仓库 nexus-aliyun central Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public Jenkins相关插件安装和配置 插件 系统管理 → 管理插件，安装插件：Maven Integration。Maven Integration这个插件用来构建maven项目 JDK配置 Maven配置 ssh配置 在系统配置中设置SSH服务器连接 SSH Servers→新增→高级→Use password authentication, or use a different key进行配置 保存后可以随时修改等信息 保存后可以随时修改信息 【测试】服务器环境安装 JDK下载与安装 JDK下载与配置 参考上一节JDK下载与安装 FreeSSHd下载与安装 FreeSSHd下载与配置 FreeSSHd最新版本下载地址 双击刚刚下载的freeSSHd.exe进行安装，安装时其他都是默认安装选项，只有最后两步会弹出对话框询问是否生成私钥和是否设置为系统服务，选择“yes\"即可，因为没有生成私钥，SSH服务将不能启动，设置系统服务的话每次开机都会自动启动SSH服务。 因为刚刚安装时选择了设置成系统服务，那么程序会马上启动，因为FREESSHD还没有配置好，我们需要打开freesshd设置窗口进行配置，因此需要把刚刚启动的服务到进程里去结束掉，否则再点击桌面打开freesshd配置时SSH服务启动不了，因为22端口被占用了。如下图，结束掉进程里面的freesshdservice.exe进程。 点开桌面的freesshd图标，开始对freesshd进行配置。第一次打开会弹出它的欢迎框，之后就不会了。 先到USER选项卡添加SSH用户，如图，添加默认的系统管理员帐号，authorization选择NT authentication，这样的话密码就是系统管理员帐号的密码。然后勾选shell选项，确定添加。 回到主界面，选择Authentication选项卡，password authentication项选择Required项，Public key authentication选择Disabled项。如果不这样设置连接的时候将会出现Access denied的错误，导致ssh客户端不能连接。 设置文件路径 右键点击任务栏下的freesshd图标点击Unload推出软件，然后重新打开freesshd软件使6步骤的配置生效。打开后点击ssh server下的Click here to start 启动SSH服务 ※关于开放22号端口或防火墙设置，此处不赘述。 Nginx下载与配置 nginx官方下载地址 解压后配置文件路径 修改配置文件nginx-1.18.0\\conf\\nginx.conf 建立构建任务 建立项目和配置SVN文件获取 项目文件生成 echo install common-utils cd code/EBD后台代码/gta-ebd/common-utils echo %cd% call mvn install cd ../bigscreen-api/ echo %cd% call mvn package cd ../../../EBD前端代码/gta-ebd-vue/ echo %cd% npm install && npm run build 将文件上传至测试服务器并执行批处理操作 批处理文件 downjar.bat @echo off & setlocal EnableDelayedExpansion title 杀死端口 title 关闭大屏后端 set port=6410 set pid=0 set pName=\"\" ::将端口所对应的进程kill掉 for /f \"tokens=2,5\" %%b in ('netstat -ano ^| findstr \":%port%\"') do ( set pid=%%c set pName=\"\" for /f \"skip=3\" %%a in ('tasklist /fi \"pid eq %%c\"') do ( set pName=%%a ) if !pName! == \"\" ( if !pName! == \"\" ( echo 端口号【%port%】已被本机释放 ) else ( echo 程序!pName!通过进程%%c在使用端口%port% taskkill /f /pid %%c echo 端口号【%port%】相关进程已杀死 ) ) ::将所对应的 if !pid! NEQ 0 ( for /f \"skip=3\" %%a in ('tasklist /fi \"pid eq %pid%\"') do ( set pName=%%a echo %%a检测失败 ) ) if !pName!==\"\" ( echo 正在启动 START javaw -Xms512m -Xmx1024m -Xmn512m -jar %~dp0bigscreen-api\\bigscreen.jar --server.port=!port! ::等待10秒钟 ping -n 10 127.0.0.1>nul echo 启动完成 )else ( echo !pName!重新启动失败，请重试 if !pid!==0 ( echo 端口号【%port%】未使用 ) else ( echo 端口号【%port%】相关进程已杀死 ) ) else ( echo 关闭失败，请重试 ) ::pause exit pause ::exit restartjar.bat @echo off & setlocal EnableDelayedExpansion title 杀死端口 title 启动大屏后端 set port=9999 set port=6410 set pid=0 set pName=\"\" ::将端口所对应的进程kill掉 for /f \"tokens=2,5\" %%b in ('netstat -ano ^| findstr \":%port%\"') do ( set pid=%%c set pName=\"\" for /f \"skip=3\" %%a in ('tasklist /fi \"pid eq %%c\"') do ( set pName=%%a ) if !pName! == \"\" ( echo 端口号【%port%】已被本机释放 ) else ( echo 程序!pName!通过进程%%c在使用端口%port% taskkill /f /pid %%c echo 端口号【%port%】相关进程已杀死 ) ) ::将所对应的 if !pid! NEQ 0 ( for /f \"skip=3\" %%a in ('tasklist /fi \"pid eq %pid%\"') do ( set pName=%%a echo %%a检测失败 ) ) if !pName!==\"\" ( if !pid!==0 ( echo 端口号【%port%】未使用 ) else ( echo 端口号【%port%】已无相关程序使用 ) ) else ( echo 关闭失败，请重试 echo 正在启动大屏后端%~dp0bigscreen.jar START javaw -Xms512m -Xmx1024m -Xmn512m -jar %~dp0bigscreen.jar --server.port=!port! ping localhost -n 10 > nul echo 启动完成 )else ( echo !pName!重新启动失败，请重试 ) pause ::exit ::pause exit setconfigvue.bat @echo off title 修改vue前端配置 cd %~dp0 echo const __host__ = \"http://10.1.136.157:6310\"; >vue/config/env.js echo const __ebdhost__=\"http://10.1.137.105:6410\"; >>vue/config/env.js echo const __doorUrl = \"http://10.1.135.40:8016/\"; >>vue/config/env.js exit Copyright © xiaoyi all right reserved，powered by Gitbook该文件修订时间： 2021-10-31 12:43:31 "}}